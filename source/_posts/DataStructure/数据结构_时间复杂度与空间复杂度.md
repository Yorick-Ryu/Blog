---
title: 时间复杂度与空间复杂度
index_img: ./img/time_complexity.png
categories: 
  - DataStructure
date: 2022-07-09 18:27:06
tags: 
  - Java
sticky: 
---

# 时间复杂度与空间复杂度

- [时间复杂度与空间复杂度](#时间复杂度与空间复杂度)
  - [度量程序(算法)执行时间的方法](#度量程序算法执行时间的方法)
    - [事后统计](#事后统计)
    - [事前估算](#事前估算)
  - [时间频度](#时间频度)
    - [基本介绍](#基本介绍)
    - [举例说明](#举例说明)
    - [时间频度的性质](#时间频度的性质)
      - [忽略常数项](#忽略常数项)
      - [忽略高次项的系数和低次项](#忽略高次项的系数和低次项)
  - [时间复杂度](#时间复杂度)
    - [常见的时间复杂度](#常见的时间复杂度)
      - [常数阶 $O(1)$](#常数阶-o1)
      - [对数阶 $O(\log_{2}{n})$](#对数阶-olog_2n)
      - [线性阶 $O(n)$](#线性阶-on)
      - [线性对数阶 $O(n\log_{2}{n})$](#线性对数阶-onlog_2n)
      - [平方阶 $O(n^2)$](#平方阶-on2)
      - [立方阶 $O(n^3)$](#立方阶-on3)
      - [k次方阶 $O(n^k)$](#k次方阶-onk)
    - [平均时间复杂度和最坏时间复杂度](#平均时间复杂度和最坏时间复杂度)
  - [空间复杂度](#空间复杂度)
    - [基本介绍](#基本介绍-1)

## 度量程序(算法)执行时间的方法

### 事后统计
这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。

### 事前估算
通过分析某个算法的时间复杂度来判断哪个算法更优。

## 时间频度

### 基本介绍
时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 $T(n)$。

### 举例说明

计算1-100所有数字之和

1. 使用for循环计算
```java
int total = 0;
int end = 100;
for(int i = 1;i <= end;i++){
    total++;
}
```
$T(n)=n+1$

2. 直接用公式计算
```java
total = (1+end)*end/2
```
$T(n)=1$

### 时间频度的性质

时间频度随着 $n$ 趋近无限大有以下性质

#### 忽略常数项

$T(n)=2n+10 \Rightarrow T(n)=2n$

#### 忽略高次项的系数和低次项

$T(n)=2n^2+3n+10 \Rightarrow T(n)=n^2$

## 时间复杂度

1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 $n$ 的某个函数，用 $T(n)$ 表示，若有某个辅助函数 $f(n)$，使得当n趋近于无穷大时， $T(n) / f(n)$ 的极限值为不等于零的常数，则称 $f(n)$ 是 $T(n)$ 的同数量级函数。记作 $T(n)=O(f(n))$，称 $O(f(n))$ 为算法的渐进时间复杂度，简称时间复杂度。

2. $T(n)$不同，但时间复杂度可能相同。如: $T(n)=n^2+7n+6$ 与 $T(n)=3n^2+2n+2$ 它们的 $T(n)$ 不同，但时间复杂度相同，都为 $O(n^2)$ 。

3. 计算时间复杂度的方法:

- 用常数 $1$ 代替运行时间中的所有加法常数
- 修改后的运行次数函数中，只保留最高阶项
- 去除最高阶项的系数

### 常见的时间复杂度

1. 常数阶 $O(1)$
2. 对数阶 $O(\log_{2}{n})$
3. 线性阶 $O(n)$
4. 线性对数阶 $O(n\log_{2}{n})$
5. 平方阶 $O(n^2)$
6. 立方阶 $O(n^3)$
7. k次方阶 $O(n^k)$
8. 指数阶 $O(2^n)$

- 常见的算法时间复杂度由小到大依次为：
$O(1)<O(\log_{2}{n})<O(n)<O(n\log_{2}{n})<O(n^2)<O(n^3)<O(n^k)<O(2^n)$，随着问题规模 $n$ 的不断增大，上述时间复杂度不断增大，算法的执行效率越低。
- 由图可见，我们应该尽可能避免使用指数阶的算法

![time_complexity](./img/time_complexity.png)

#### 常数阶 $O(1)$

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 $O(1)$

#### 对数阶 $O(\log_{2}{n})$

```java
int i = 1;
while(i < n){
  i = i * 2;
}
```
说明：在while循环里面，每次都将 i 乘以 2 ，乘完之后，i 距离 n 就越来越近了。假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 $x=\log_{2}{n}$ 也就是说当循环 $\log_{2}{n}$ 次以后，这个代码就结束了。因此这个代码的时间复杂度为：$O(\log_{2}{n})$ 。$O(\log_{2}{n})$ 的这个 2 时间上是根据代码变化的，若`i = i * 3`，则是 $O(\log_{3}{n})$。

#### 线性阶 $O(n)$

```java
int j = 0;
for(int i = 0;i < n;i++){
  j++;
}
```
说明：这段代码，for循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 $O(n)$ 来表示它的时间复杂度。

#### 线性对数阶 $O(n\log_{2}{n})$

```java
for(int m = 0;m < n;m++){
  int i = 1;
  while(i < n){
    i = i * 2;
  }
}
```

说明：线性对数阶 $O(n\log_{2}{n})$ 其实非常容易理解，将时间复杂度为 $O(\log_{2}{n})$ 的代码循环 $n$ 遍的话，那么它的时间复杂度就是  $n*O(\log_{2}{n})$ ，也就是 $O(n\log_{2}{n})$ 。


#### 平方阶 $O(n^2)$

常见于双层循环嵌套

#### 立方阶 $O(n^3)$

常见于三层循环嵌套

#### k次方阶 $O(n^k)$

常见于 k 层循环嵌套

### 平均时间复杂度和最坏时间复杂度
1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2. 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是:最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
3. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关。

## 空间复杂度

### 基本介绍

1.  类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。
2. 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。
3. 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。
