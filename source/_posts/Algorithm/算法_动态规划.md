---
title: 动态规划
index_img: /img/default.png
categories: 
  - algorithm
date: 2022-08-08 15:34:20
tags: 
  - Java
sticky: 
---

# 动态规划

- [动态规划](#动态规划)
  - [动态规划解决背包问题](#动态规划解决背包问题)
    - [基本介绍](#基本介绍)
    - [思路分析](#思路分析)
    - [代码实现](#代码实现)

（1）动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法。

（2）动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

（3）与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)

（4）动态规划可以通过填表的方式来逐步推进，得到最优解。

## 动态规划解决背包问题

### 基本介绍

背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包（完全背包指的是：每种物品都有无限件可用）

这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。

### 思路分析

算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，c为背包的容量。再令v[i][i]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：

（1）`v[i][0]=v[0][i]=0`，表示填入表的第一行和第一列都是0。

（2）当`w[i]>j`时：`v[i][j]=v[i-1][j]`，当准备加入新增的商品的容量大于当前背包的容量时，就直接使用上一个单元格的装入策略

（3）当`j>=w[i]`时：`v[i][j]=max{v[i-1][j],v[i]+v[i-1][j-w[i]}`，当准备加入新增的商品的容量小于等于当前背包的容量时，装入的方式。分析：
- `v[i-1][j]`：上一个单元格的装入策略
- `v[i]`：表示当前商品的价值
- `v[i-1][j-w[i]]`：装入i-1商品到剩余空间`j-w[i]`最大值

### 代码实现
```java
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w = {1, 4, 3};// 物品重量
        int[] v = {1500, 3000, 2000};// 物品价值
        int m = 4;// 背包容量
        int n = v.length;// 物品的个数


        // 创建二维数组，表示在前i个物品中能够装入容量为m的背包中的最大价值
        int[][] val = new int[n + 1][m + 1];
        // 记录具体商品
        String[][] path = new String[n + 1][m + 1];
        // 使填入表的第一行和第一列都是0。
        for (int i = 0; i < m + 1; i++) {
            val[0][i] = 0;
            path[0][i] = "";
        }
        for (int i = 0; i < n + 1; i++) {
            val[i][0] = 0;
            path[i][0] = "";
        }

        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < m + 1; j++) {
                // 当准备加入新增的商品的容量大于当前背包的容量时，
                // 就直接使用上一个单元格的装入策略
                if (w[i - 1] > j) {
                    val[i][j] = val[i - 1][j];
                    path[i][j] = path[i - 1][j];
                } else {
                    // 当准备加入新增的商品的容量小于等于当前背包的容量时，装入的方式
                    if (val[i - 1][j] > v[i - 1] + val[i - 1][j - w[i - 1]]) {
                        val[i][j] = val[i - 1][j];
                        path[i][j] = path[i - 1][j];
                    } else {
                        val[i][j] = v[i - 1] + val[i - 1][j - w[i - 1]];
                        path[i][j] = i - 1 + "号 " + path[i - 1][j - w[i - 1]];
                    }
                }
            }
        }
        // 输出
        for (int i = 1; i < n + 1; i++) {
            System.out.println(Arrays.toString(val[i]));
        }
        for (int i = 1; i < n + 1; i++) {
            System.out.println(Arrays.toString(path[i]));
        }
        System.out.println("背包的最大价值：" + val[n][m]);
        System.out.println("背包里的物品号：" + path[n][m]);
    }
}
```
输出
```java
[0, 1500, 1500, 1500, 1500]
[0, 1500, 1500, 1500, 3000]
[0, 1500, 1500, 2000, 3500]
[, 0号 , 0号 , 0号 , 0号 ]
[, 0号 , 0号 , 0号 , 1号 ]
[, 0号 , 0号 , 2号 , 2号 0号 ]
背包的最大价值：3500
背包里的物品号：2号 0号 
```